# Joshua Udrea
# CS350 Emerging Sys Arch & Tech
# This will Detail what I did within CS350 Emerging Sys Arch and Tech

# Project Summary and Problem Solved
The main focus of this course project was to design and implement software to interface directly with hardware components using a breadboard and microcontroller setup. The project aimed to solve the problem of how to control and monitor hardware systems through software—specifically writing efficient code that could reliably manage hardware signals and timing while maintaining system stability. The challenge was to create a functional and maintainable system that demonstrated both a strong understanding of emerging systems architectures and the integration of hardware and software components.

# What I Did Well
One thing I did particularly well was troubleshooting complex hardware and wiring issues. Early on, I struggled with incorrect wiring configurations and inconsistent behavior between the circuit and software, but I stayed persistent and methodical. I learned how to isolate variables—testing components one by one, verifying voltage readings, and using documentation to confirm pin connections. My persistence paid off when I successfully established stable communication between the hardware and my interface code.

# Areas for Improvement
If I could improve one aspect, it would be planning and documentation during the wiring phase. At first, I underestimated how easily wiring errors could derail progress. In the future, I plan to use more detailed schematics and labeling from the start to avoid confusion and save debugging time. Additionally, I’d like to strengthen my understanding of timing synchronization and hardware interrupt handling, which are key for optimizing performance.

# Tools and Resources Added to My Support Network
Throughout this project, I relied on a combination of online microcontroller documentation, breadboard wiring guides, and community forums like Stack Overflow. I also used debugging tools and serial monitors to analyze data flow between components. These resources have become part of my ongoing toolkit for any hardware-related project, and I’ll continue using them in future development work.

# Transferable Skills
The skills I developed here—especially hardware-software integration, troubleshooting, and system-level analysis—are highly transferable to other areas of computer science. Whether I’m working on embedded systems, IoT devices, or performance-critical applications, these experiences have improved my ability to think critically about how hardware design affects software behavior and performance.

# Maintainability, Readability, and Adaptability
I made the project maintainable by following modular coding practices and writing clear inline comments explaining each section of the code. I also organized the wiring layout to correspond logically with the code structure, which made it easier to adjust connections or expand functionality later. By separating configuration parameters and using descriptive variable names, the system can be adapted to different hardware setups without rewriting the entire program.
